# 保姆级从零到一手把手教你造一个企业级微前端框架

## 前言

微前端是目前比较热门的一种技术架构，挺多读者想了解其中的原理。为了讲清楚原理，我会带着大家从零开始实现一个微前端框架，其中包含了以下功能：

- 如何进行路由劫持
- 如何渲染子应用
- 如何实现 JS 沙箱及样式隔离
- 提升体验性的功能

另外在实现的过程中，笔者还会聊聊目前有哪些技术方案可以去实现微前端以及做以上功能的时候有哪些实现方式。

这里是本次文章的最终产出物仓库地址：[toy-micro](https://github.com/KieSun/toy-micro)。

## 微前端实现方案

微前端的实现方案有挺多，比如说：

1. [qiankun](https://github.com/umijs/qiankun)，自己实现 JS 及样式隔离
2. [icestark](https://github.com/ice-lab/icestark)，iframe 方案，浏览器原生隔离，但存在一些问题
3. [emp](https://github.com/efoxTeam/emp)，Webpack 5 Module Federation（联邦模块）方案
4. WebComponent 等方案

但是这么多实现方案解决的场景问题还是分为两类：

- 单实例：当前页面只存在一个子应用，一般使用 qiankun 就行
- 多实例：当前页面存在多个子应用，可以使用浏览器原生隔离方案，比如 iframe 或者 WebComponent 这些

当然了，并不是说单实例只能用 qiankun，浏览器原生隔离方案也是可行的，只要你接受它们带来的不足就行：

> iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

上述内容摘自[Why Not Iframe](https://www.yuque.com/kuitos/gky7yw/gesexv)。

本文的实现方案和 qiankun 一致，但是其中涉及到的功能及原理方面的东西都是通用的，你换个实现方案也需要这些。

## 技术架构图

TODO

## 前置工作

在正式开始之前，我们需要搭建一下开发环境，这边大家可以任意选择主 / 子应用的技术栈，比如说主应用用 React，子应用用 Vue，自行选择即可。每个应用用对应的脚手架工具初始化项目就行，这边就不带着大家初始化项目了。记得如果是 React 项目的话，需要另外再执行一次 `yarn eject`。

大家也可以直接使用笔者[仓库](https://github.com/KieSun/toy-micro)里的 example 文件夹，主应用为 React，子应用为 Vue，最终我们生成的目录结构大致如下：

![截屏2021-08-30下午10.15.01](https://yck-1254263422.file.myqcloud.com/uPic/UAjV2m.png)

## 正文

> 在阅读正文前，我假定各位读者已经使用过微前端框架并了解其中的概念，比如说知晓主应用是负责整体布局以及子应用的配置及注册这类内容。如果还未使用过，推荐各位简略阅读下任一微前端框架使用文档。

### 应用注册

在有了主应用之后，我们需要先在主应用中注册子应用的信息，内容包含以下几块：

- name：子应用名词
- entry：子应用的资源入口
- container：主应用渲染子应用的节点
- activeRule：在哪些路由下渲染该子应用

其实这些信息和我们在项目中注册路由很像，`entry` 可以看做需要渲染的组件，`container` 可以看做路由渲染的节点，`activeRule` 可以看做如何匹配路由的规则。

接下来我们先来实现这个注册子应用的函数：

```ts
// src/types.ts
export interface IAppInfo {
  name: string;
  entry: string;
  container: string;
  activeRule: string;
}

// src/start.ts
export const registerMicroApps = (appList: IAppInfo[]) => {
  setAppList(appList);
};

// src/appList/index.ts
let appList: IAppInfo[] = [];

export const setAppList = (list: IAppInfo[]) => {
  appList = list;
};

export const getAppList = () => {
  return appList;
};
```

上述实现很简单，就只需要将用户传入的 `appList` 保存起来即可。

### 路由劫持

在有了子应用列表以后，我们需要启动微前端以便渲染相应的子应用，也就是需要判断路由来渲染相应的应用。但是在进行下一步前，我们需要先考虑一个问题：**如何监听路由的变化来判断渲染哪个子应用？**

对于非 SPA（单页应用） 架构的项目来说，这个完全不是什么问题，因为我们只需要在启动微前端的时候判断下当前 URL 并渲染应用即可；**但是在 SPA 架构下，路由变化是不会引发页面刷新的，因此我们需要一个方式知晓路由的变化，从而判断是否需要切换子应用或者什么事都不干。**

如果你了解过 Router 库原理的话，应该马上能想到解决方案。如果你并不了解的话，可以先自行阅读笔者之前的[文章](https://github.com/KieSun/awesome-frontend-source-interpretation/blob/master/article/vue/VueRouter%20%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.md)。

为了照顾不了解的读者，笔者这里先简略的聊一下路由原理。

目前单页应用使用路由的方式分为两种：

1. hash 模式，也就是 URL 中携带 `#`
2. histroy 模式，也就是常见的 URL 格式了

以下笔者会用两张图例展示这两种模式分别会涉及到哪些事件及 API：

![img](https://camo.githubusercontent.com/98032a7a12b97d96c01ddf3ec697c578082da6d9a5fcb5451c849737d761f577/68747470733a2f2f79636b2d313235343236333432322e636f732e61702d7368616e676861692e6d7971636c6f75642e636f6d2f626c6f672f323031392d30362d30312d3033333135372e706e67)

![img](https://camo.githubusercontent.com/f93987d12dbd342743eca9ab3ccc0f971053a0958c55c6318132a8d529c62735/68747470733a2f2f79636b2d313235343236333432322e636f732e61702d7368616e676861692e6d7971636c6f75642e636f6d2f626c6f672f323031392d30362d30312d3033333135392e706e67)

从上述图中我们可以发现，路由变化会涉及到两个事件：

- `popstate`
- `hashchange`

因此这两个事件我们肯定是需要去监听的。除此之外，调用 `pushState` 以及 `replaceState` 也会造成路由变化，但不会触发事件，因此我们还需要去重写这两个函数。

知道了该监听什么事件以及重写什么函数之后，接下来我们就来实现代码：

```ts
// src/route/index.ts

// 保存原有方法
const originalPush = window.history.pushState;
const originalReplace = window.history.replaceState;

export const hijackRoute = () => {
  // 重写方法
  window.history.pushState = (...args) => {
    // 调用原有方法
    originalPush.apply(window.history, args);
    // URL 改变逻辑，实际就是如何处理子应用
    // ...
  };
  window.history.replaceState = (...args) => {
    originalReplace.apply(window.history, args);
    // URL 改变逻辑
    // ...
  };

  // 监听事件，触发 URL 改变逻辑
  window.addEventListener("hashchange", () => {});
  window.addEventListener("popstate", () => {});

  // 重写
  window.addEventListener = hijackEventListener(window.addEventListener);
  window.removeEventListener = hijackEventListener(window.removeEventListener);
};

const capturedListeners: Record<EventType, Function[]> = {
  hashchange: [],
  popstate: [],
};
const hasListeners = (name: EventType, fn: Function) => {
  return capturedListeners[name].filter((listener) => listener === fn).length;
};
const hijackEventListener = (func: Function): any => {
  return function (name: string, fn: Function) {
    // 如果是以下事件，保存回调函数
    if (name === "hashchange" || name === "popstate") {
      if (!hasListeners(name, fn)) {
        capturedListeners[name].push(fn);
        return;
      } else {
        capturedListeners[name] = capturedListeners[name].filter(
          (listener) => listener !== fn
        );
      }
    }
    return func.apply(window, arguments);
  };
};
```

以上代码看着很多行，实际做的事情很简单，总体分为以下几步：

1. 重写 `pushState` 以及 `replaceState` 方法，在方法中调用原有方法后执行如何处理子应用的逻辑
2. 监听 `hashchange` 及 `popstate` 事件，事件触发后执行如何处理子应用的逻辑
3. 重写监听 / 移除事件函数，如果应用监听了 `hashchange` 及 `popstate` 事件就将回调函数保存起来以备后用

### 应用生命周期

在实现路由劫持后，我们现在需要来考虑如果实现处理子应用的逻辑了，也就是如何处理子应用加载资源以及挂载和卸载子应用。看到这里，大家是不是觉得这和组件很类似。组件也同样需要处理这些事情，并且会暴露相应的生命周期给用户去干想干的事。

因此对于一个子应用来说，我们也需要去实现一套生命周期，既然子应用有生命周期，主应用肯定也有，而且也必然是相对应子应用生命周期的。

那么到这里我们大致可以整理出来主 / 子应用的生命周期。

对于主应用来说，分为以下三个生命周期：

1. `beforeLoad`：挂载子应用前
2. `mounted`：挂载子应用后
3. `unmounted`：卸载子应用

当然如果你想增加生命周期也是完全没问题的，笔者这里为了简便就只实现了三种。

对于子应用来说，通用也分为以下三个生命周期：

1. `bootstrap`：首次应用加载触发，常用于配置子应用全局信息
2. `mount`：应用挂载时触发，常用于渲染子应用
3. `unmount`：应用卸载时触发，常用于销毁子应用

接下来我们就来实现这些生命周期函数：

```ts
// src/types.ts
export interface ILifeCycle {
  beforeLoad?: LifeCycle | LifeCycle[];
  mounted?: LifeCycle | LifeCycle[];
  unmounted?: LifeCycle | LifeCycle[];
}

// src/start.ts
// 改写下之前的
export const registerMicroApps = (
  appList: IAppInfo[],
  lifeCycle?: ILifeCycle
) => {
  setAppList(appList);
  lifeCycle && setLifeCycle(lifeCycle);
};

// src/lifeCycle/index.ts
let lifeCycle: ILifeCycle = {};

export const setLifeCycle = (list: ILifeCycle) => {
  lifeCycle = list;
};
```

因为是主应用的生命周期，所以我们在注册子应用的时候就顺带注册上了。

```ts
// src/enums.ts
// 设置子应用状态
export enum AppStatus {
  NOT_LOADED = 'NOT_LOADED',
  LOADING = 'LOADING',
  LOADED = 'LOADED',
  BOOTSTRAPPING = 'BOOTSTRAPPING',
  NOT_MOUNTED = 'NOT_MOUNTED',
  MOUNTING = 'MOUNTING',
  MOUNTED = 'MOUNTED',
  UNMOUNTING = 'UNMOUNTING',
}
// src/lifeCycle/index.ts
export const runBeforeLoad = async (app: IInternalAppInfo) => {
  app.status = AppStatus.LOADING
  await runLifeCycle('beforeLoad', app)

  app = await 加载子应用资源
  app.status = AppStatus.LOADED
}

export const runBoostrap = async (app: IInternalAppInfo) => {
  if (app.status !== AppStatus.LOADED) {
    return app
  }
  app.status = AppStatus.BOOTSTRAPPING
  await app.bootstrap?.(app)
  app.status = AppStatus.NOT_MOUNTED
}

export const runMounted = async (app: IInternalAppInfo) => {
  app.status = AppStatus.MOUNTING
  await app.mount?.(app)
  app.status = AppStatus.MOUNTED
  await runLifeCycle('mounted', app)
}

export const runUnmounted = async (app: IInternalAppInfo) => {
  app.status = AppStatus.UNMOUNTING
  await app.unmount?.(app)
  app.status = AppStatus.NOT_MOUNTED
  await runLifeCycle('unmounted', app)
}

const runLifeCycle = async (name: keyof ILifeCycle, app: IAppInfo) => {
  const fn = lifeCycle[name]
  if (fn instanceof Array) {
    await Promise.all(fn.map((item) => item(app)))
  } else {
    await fn?.(app)
  }
}
```

以上代码实现也很简单，总结一下就是：

- 设置子应用状态，用于逻辑判断以及优化。比如说当一个应用状态为非 `NOT_LOADED` 时（每个应用初始都为 `NOT_LOADED` 状态），下次渲染该应用时就无需重复加载资源了
- 如有需要处理逻辑，比如说 `beforeLoad` 我们需要加载子应用资源
- 执行主 / 子应用生命周期，这里需要注意下执行顺序，可以参考父子组件的生命周期执行顺序

### 完善路由劫持

实现应用生命周期以后，我们现在就能来完善先前路由劫持中没有做的「如何处理子应用」的这块逻辑。

